<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>综合测试练习</title>

    <style>
        body{
            margin:0;
            overflow:hidden;
        }
    </style>

</head>
<body>
<script type="text/javascript"  src="../main/three.js"></script>

<script type="text/javascript"  src="../lib/js/loaders/OBJLoader.js"></script>
<script type="text/javascript"  src="../lib/js/loaders/MTLLoader.js"></script>
<script type="text/javascript"  src="../lib/js/loaders/DDSLoader.js"></script>
<script type="text/javascript"  src="../lib/js/loaders/ColladaLoader.js"></script>

<script type="text/javascript"  src="../lib/js/controls/OrbitControls.js"></script>

<script type="text/javascript"  src="../lib/js/Detector.js"></script>
<script type="text/javascript"  src="../lib/js/libs/stats.min.js"></script>

<script type="text/javascript"  src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

<script type="text/javascript"  src="../lib/js/libs/tween.min.js"></script>

<script type="text/javascript"  src="../lib/js/TypedArrayUtils.js"></script>

<script>


    var rayPoint = new Array();                                                                                       //     射线源

    var positions = new Float32Array(8*3);                                                                            //  8个三维坐标
    var kdtree ;                                                                                                       //   KD-Tree


    var isMove=false;
    var isMoveCount = 0;                                                                                               // 判断是否为房屋室内 相机旋转

    var isMouseDown = false;

    var isInHome =false;                                                                                                //判断相机是否在房屋内

    var intentMouseRotate =false;                                                                                       //鼠标拖拽旋转模型意图


    var xchange=0,zchange=0,ychange=0;



    var    thetaAzimuthal = 0, thetaPlolar=0;

    $(function () {
        $.ajax(
            {
                type:"get",
                url:"src/VT_Model_info.json",
                dataType:"json",
                success:function(result){
                    addBox(result);
                }
            }
        );
    });
    // ajax  提取  json 数据函数   ---   jq
    function addBox(result){
        var i=0;

        $.each(result,function(index,obj)
            {
                i++;
                if(i==5) {
                    for (var j = 0; j < obj[0].length; j++) {
                        // console.log("初始:"+obj[0][j]['matrix'][3]+","+obj[0][j]['matrix'][7]+","+obj[0][j]['matrix'][11] );
                        rayPoint[j]=new THREE.Vector3(obj[0][j]['matrix'][3],obj[0][j]['matrix'][7],obj[0][j]['matrix'][11]);               //将json  4*4变换矩阵中3，7，11 坐标保存到 rayPoint数组

                        rayPoint[j].applyAxisAngle(new THREE.Vector3(1,0,0),Math.PI/2);                                                     // applyAxisAngle() 实现 绕（1，0，0）向量    旋转  pi/2

                        console.log("数据采集点:"+j+"("+obj[0][j]['matrix'][3]+","+obj[0][j]['matrix'][7]+","+obj[0][j]['matrix'][11] +")");

                        // console.log("变换后:"+rayPoint[j].x+","+rayPoint[j].y+","+rayPoint[j].z);
                        /*           实现了相机自传            未实现 相机绕x轴转
                        //console.log(rayPoint[j]+"----"+j);
                        var cube = new THREE.PerspectiveCamera();
                        cube.position.set( rayPoint[j].x,rayPoint[j].y,rayPoint[j].z );
                        console.log(cube.position);
                        cube.applyAxisAngle(new THREE.Vector3(1,0,0),Math.PI/2);
                        console.log("旋转后："+cube.position.x+","+cube.position.y+","+cube.position.z);
                            */

                    }
                }
            }
        );
    }



    var container;
    var camera,scene,renderer,camera1;
    var helper;
    var helperSphere;
    var mesh;
    var controls;

    var targetX=0,targetY=0,targetZ=0;


    var mouse = new THREE.Vector2();
    var raycaster = new THREE.Raycaster()

    // var   rayOrigin = new THREE.Vector3(0,0,0);    //  射线源点
    var   rayDirection = new THREE.Vector3(0,-1,0);   // 射线方向              xz面法向量

    init();
    animate();

    function init(){

        container = document.createElement('div');
        document.body.appendChild( container );

        camera = new THREE.PerspectiveCamera(45,window.innerWidth/window.innerHeight,0.01,2000);                       //相机基本属性

        var initX=1.916,initY=6.143,initZ=17.256;

        camera.position.set(initX,initY,initZ);                                                                         //  相机初始位置

        console.log("透视相机初始位置"+initX+','+initY+','+initZ)

        console.log("相机初始朝向0,0,0");

        scene = new THREE.Scene();

        var ambientLight = new THREE.AmbientLight(0xcccccc,0.4);

        console.log("环境光RGB：0xcccccc, 强度:0.4");

        scene.add(ambientLight);

        var pointLight = new THREE.PointLight(0xffffff,0.8);

        console.log("点光RGB:0xfffffff,强度0.8");
        camera.add(pointLight);
        scene.add(camera);

        var onProgress = function (xhr){
            if(xhr.lengthComputable){
                var percentComplete = xhr.loaded/xhr.total*100;
                console.log( Math.round(percentComplete,2)+'% downloaded');
            }
        };

        var onError = function(xhr){ };

        THREE.Loader.Handlers.add(/\.dds$/i,new THREE.DDSLoader());

        var mtlLoader = new THREE.MTLLoader();
        mtlLoader.setPath('src/floor3/');
        mtlLoader.load('VT_Model.mtl',function (materials) {

            materials.preload();

            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            objLoader.setPath('src/floor3/');
            objLoader.load('VT_Model.obj', function (object) {                                                     //模型加载

                mesh = object;  // 获取obj 对象 并保存

                mesh.rotation.x = Math.PI / 2;                                                                       //模型绕x轴旋转  pi/2
                scene.add(object);
            }, onProgress, onError);

        });

        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth,window.innerHeight);
        container.appendChild(renderer.domElement);

        //helper

        var gridHelper = new THREE.GridHelper(10,20);
        //scene.add(gridHelper);                                                                                      //地面辅助工具

        //controls                                                                                                        轨道控制器
        controls = new THREE.OrbitControls(camera,renderer.domElement);

        controls.enableDamping = true;

        controls.dampingFactor = 0.5;
        console.log('dampingFactor:'+controls.dampingFactor);


        // controls.dampingFactor = false;

        //controls.target.set(targetX,targetY,targetZ);                                                            //   controls.target


        // camera1.lookAt(0,0,0);                     // 过渡相机  初始朝向

        // show axes in the screen
        var axes = new THREE.AxesHelper(20);
        // scene.add(axes);                                                                                                  //辅助坐标系

        // mouseHelper

        helperSphere =  new THREE.Mesh(new THREE.SphereGeometry(.05,20,20),new THREE.MeshNormalMaterial());

        scene.add(helperSphere);                                                                                            //辅助小球




        document.addEventListener('mousemove',onDocumentMouseMove,false);

        window.addEventListener('resize',onWindowResize,false);


        var geometry = new THREE.CubeGeometry(.1,.1,.1);

        //  helper = new THREE.Mesh( geometry, new THREE.MeshNormalMaterial() );

        helper = new Array();

        for(var i=0;i<8;i++)                                                                                        // 场景添加辅助小立方体
        {
            helper[i]=  new THREE.Mesh( geometry, new THREE.MeshNormalMaterial() );
            helper[i].position.set(rayPoint.x,rayPoint.y,rayPoint.z);
            scene.add(helper[i]);
        }

        var distanceFunction = function ( a, b ) {
            return Math.pow( a[ 0 ] - b [0 ], 2 ) +  Math.pow( a[ 1 ] - b[ 1 ], 2 ) +  Math.pow( a[ 2 ] - b[ 2 ], 2 );          //   求两点距离平方 函数
        };


        document.onmousedown = function () {

            // console.log("当前相机位置:"+camera1.position.x+','+camera1.position.y+','+camera1.position.z);
            //  console.log("当前朝向lookat"+lookatx+','+lookaty+','+lookatz);

            //   console.log("lookatx:"+lookatx);
            isMove =false;
            //      console.log("xchange:"+xchange);

            isMoveCount = 0;
            isMouseDown = true;
            console.log("按下鼠标");
        }



        document.onmouseup = function () {                                                                          // 鼠标点击事件  mouseup

            //controls.update();

           // isMove =false;

            isMouseDown = false;
            console.log("松开鼠标按键");
           // console.log(isMoveCount);
            if(1==isMoveCount)
            {
                console.log("换角度观察房间意图取消");
            }
            //  console.log(controls.target);

            for(var i=0;i<8;i++) {

                raycaster.set(rayPoint[i], rayDirection);                                                            //设置射线源点  与方向         射线在地面的投影


                //  console.log("射线在地面的投影:");

                var intersects = raycaster.intersectObjects(mesh.children, true);

                //  console.log(intersects[0]['distance']);                                                              // distance

                if (intersects.length > 0) {
                    helper[i].position.set(intersects[0].point.x, intersects[0].point.y, intersects[0].point.z);     //  intersects[0]  这里表示射线与房屋模型对象的第一个交点
                    //    console.log(helper[i].position.x+","+helper[i].position.y+","+helper[i].position.z);

                    positions[i*3+0] = intersects[0].point.x;
                    positions[i*3+1] = intersects[0].point.y;
                    positions[i*3+2] = intersects[0].point.z;                                                       //  将8个投影点 存放在 positions 数组里;

                }

            }

            kdtree  = new THREE.TypedArrayUtils.Kdtree(positions,distanceFunction,3);                                 // KD-Tree

            //  console.log(positions);
            // console.log(kdtree);

            mouse.x = (event.clientX / renderer.domElement.clientWidth )*2-1;

            mouse.y = -(event.clientY / renderer.domElement.clientHeight )*2+1;

            raycaster.setFromCamera(mouse,camera);                                                                 // camera  射线的起点     mouse 为鼠标移动所在的 二维坐标

            var intersects = raycaster.intersectObjects(mesh.children,true);                                        //这里指的是房屋模型的所有对象

            if(intersects.length>0) {

                controls.rotateSpeed = -1;                                                                              //  旋转速度


                var  x  =  camera.position.x;
                var  y  =  camera.position.y;
                var  z  =  camera.position.z;                                                                      //原相机坐标;

                var  x1 =  intersects[0].point.x;
                var  y1 =  intersects[0].point.y;
                var  z1 =  intersects[0].point.z;                                                                   //  射线与模型第一个交点坐标;   intersects[0]  这里表示射线与房屋模型对象的第一个交点


                //  console.log(y1);

                var nearestPoint = kdtree.nearest([x1,y1,z1],1,20);                                                 //  最临近点

                //      console.log('最近投影点：'+nearestPoint[0][0]['obj'][0]+','+nearestPoint[0][0]['obj'][1]+','+nearestPoint[0][0]['obj'][2]);             //   kdtree -- nearest



                var xm =  nearestPoint[0][0]['obj'][0] ;
                var ym =  nearestPoint[0][0]['obj'][1] ;
                var zm =  nearestPoint[0][0]['obj'][2] ;

                //console.log(ym);


                xchange =  (x1 - x);
                zchange =  (z1 - z);
                ychange =  (y1 - y);

                // console.log(xchange+'---'+zchange);
                /*          camera1 position
                                    new TWEEN.Tween(camera1.position).to(                                                               // Tween  camera1.position
                                        {
                                            x:xm,
                                            y:ym,
                                            z:zm
                                        },2000)
                                        .easing(TWEEN.Easing.Quadratic.InOut)
                                        .onUpdate(function () {

                                            //console.log(xchange+','+zchange);
                                        })
                                        .start();
                                    */

                if(controls.getPolarAngle()-0.0001>0&&isMoveCount<2)                                                   //  过滤垂直俯视,转向移动

                {

                    if(y1>-1.4&&y1<-1.2)                                                                                     //是否点击地面
                    {
                                if(isInHome==false)                                                                         //是否从室外点击地面
                                {

                                        new TWEEN.Tween(camera.position).to(                                                //相机平移到数据采集点
                                        {
                                            x:xm,
                                            y:0,
                                            z:zm
                                        },1500)
                                        .easing(TWEEN.Easing.Quadratic.InOut)

                                        .start();                                                                               //Tween  camera.position

                                    new TWEEN.Tween(controls.target).to({                                                       //  controls.target 抬升效果

                                        x:xm+camera.getWorldDirection().x/32,
                                        y:0,
                                        z:zm+camera.getWorldDirection().z/32

                                    },1500)
                                        .easing(TWEEN.Easing.Quadratic.InOut)
                                        .start();

                                    console.log("优雅的进入房间    ----TweenJs 渐变   相机平移并抬升");
                                    isInHome = true;                                                                    //表示相机已经进入房间
                                }else{                                                                                  //在室内移动

                                    console.log("相机朝向 向量（xyz):"+camera.getWorldDirection().x+","+camera.getWorldDirection().y+","+camera.getWorldDirection().z);

                                    new TWEEN.Tween(camera.position).to(
                                        {
                                            x:xm,
                                            y:0,
                                            z:zm
                                        },1000)
                                        .easing(TWEEN.Easing.Quadratic.InOut)

                                        .start();                                                                               //Tween  camera.position


                                    new TWEEN.Tween(controls.target).to({                                                       //  controls.target 抬升效果

                                        x:xm+camera.getWorldDirection().x/32,
                                        y:0+camera.getWorldDirection().y/32,
                                        z:zm+camera.getWorldDirection().z/32

                                    },1000)
                                        .easing(TWEEN.Easing.Quadratic.InOut)
                                        .start();

                                }

                    }else                                                                                               //非地面情况
                    {

                        if( isInHome==true )                                                                              // 在房间内
                        {
                            console.log("不在地面上"+x1+','+y1+','+z1);

                            if(x1>-0.9&&x1<-0.4  &&y1>-0.6&&y1<0 && z1>-2&&z1<1.1)   {                     //在屋内点击电视区域
                            console.log("优雅的退出房间   ----- 点击电视区域退出房间")
                            // -0.8880877192072782,-0.5761502941342928,-1.130744562678091
                            // -0.8802677042998384,-0.04991820897111332,-1.1113757947196676
                            // -0.4203266577384608,-0.601510209665427,-1.9718166111677717
                            // -0.4060523606258606,-0.03489494268334988,-1.9700081400208544
                            new TWEEN.Tween(camera.position).to(
                                {
                                    x:x - camera.getWorldDirection().x*6,
                                    y:initY,
                                    z:z - camera.getWorldDirection().z*6
                                },1500)
                                .easing(TWEEN.Easing.Quadratic.InOut)
                                .start();


                            isInHome = false;                                                                           //平滑退出房间
                            controls.rotateSpeed = 1;
                            }
                        }

                    }


                }


                /*     交点
                new TWEEN.Tween(camera1.position).to({
                    x:x2,
                    y:y2,
                    z:z2
                },2000).easing(TWEEN.Easing.Quadratic.InOut).start();                                                 //  http://sole.github.io/tween.js/examples/03_graphs.html
                */

                //camera.lookAt(x1,y1,z1);   //  相机朝向 交点;



                /*
                                    new TWEEN.Tween(controls.target).to({
                                        x:0,
                                        y:0,
                                        z:z1
                                    },1000).easing(TWEEN.Easing.Quadratic.InOut).start();
                */
                // console.log(camera1);

            }

        }




        function  onWindowResize(){

            // windowHalfX = window.innerWidth/2;

            //  windowHalfY = window.innerHeight/2;

            camera.aspect = window.innerWidth / window.innerHeight;

            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth,window.innerHeight);

        }


        function onDocumentMouseMove (event ){

            //isMoveCount = 0;
            isMoveCount++;
            isMove =true;




            if(isInHome == false)
            {                                                                                                            //鼠标室外移动

                    console.log("-----正在室外移动鼠标")
                    if(isMouseDown==true&&isMoveCount==3)
                    {


                        console.log("正在室外观察房间   --------- 室外旋转模型，方向:"+controls.rotateSpeed);
                    }

                    if(isMouseDown==true&&isMoveCount==1)
                    {

                        intentMouseRotate = true;
                        console.log("有换角度观察房间意图(外）--------鼠标准备拖拽移动模型");
                    }

            }
            else                                                                                                   //鼠标室内移动
            {
                    console.log("-----鼠标在室内移动");
                    if(isMouseDown==true&&isMoveCount>=3)
                    {
                        console.log("正在室内观察房间   --------- 室外旋转模型，方向:"+controls.rotateSpeed);
                        console.log(controls.target);
                        console.log("相机朝向 向量（xyz):"+camera.getWorldDirection().x+","+camera.getWorldDirection().y+","+camera.getWorldDirection().z);


                    }

                    if(isMouseDown==true&&isMoveCount==1)
                    {

                        intentMouseRotate = true;
                        console.log("有换角度观察房间意图（内）   --------  鼠标准备拖拽移动模型");
                    }
            }

        // console.log(isMoveCount);
            //  [-1,1]

            // console.log("camera.posiont xyz:"+camera.position.x+","+camera.position.y+","+camera.position.z);

            // console.log("control.target xyz:"+targetX+","+targetY+","+targetZ);

            //  console.log(controls.getAzimuthalAngle()+'--垂直--:::'+controls.getPolarAngle());

            mouse.x = (event.clientX / renderer.domElement.clientWidth )*2-1;

            mouse.y = -(event.clientY / renderer.domElement.clientHeight )*2+1;

            raycaster.setFromCamera(mouse,camera);  // camera  射线的起点     mouse 为鼠标移动所在的 二维坐标

            var intersects = raycaster.intersectObjects(mesh.children,true);//这里指的是房屋模型的所有对象

            if(intersects.length>0) {

                helperSphere.position.set(intersects[0].point.x, intersects[0].point.y, intersects[0].point.z);//  intersects[0]  这里表示射线与房屋模型对象的第一个交点

                //console.log("鼠标在模型上----------------模型交点世界坐标为"+intersects[0].point.x+','+ intersects[0].point.y+','+ intersects[0].point.z);

            }

            //   console.log(rayPoint[i]);
            // console.log(helper[i]);
        }

        /*
         console.log(mouse.x,mouse.y)

         raycaster.setFromCamera(mouse,camera);  // camera  射线的起点     mouse 为鼠标移动所在的 二维坐标

         var intersects = raycaster.intersectObjects(mesh.children,true);//这里指的是房屋模型的所有对象

           if(intersects.length>0){

               helper.position.set(intersects[0].point.x,intersects[0].point.y,intersects[0].point.z);//  intersects[0]  这里表示射线与房屋模型对象的第一个交点


               console.log(intersects[0]);

               console.log("射线与对象的交叉点数 length:"+intersects.length);

               console.log("射线源 向量：" + camera.position.x+','+camera.position.y+','+camera.position.z);

               console.log("在世界坐标中的第一个交叉点坐标："+intersects[0].point.x+','+intersects[0].point.y+','+intersects[0].point.z );

               console.log("射线源到第一个交点的距离:"+intersects[0].distance);

               console.log("第一个相交面："+intersects[0].face);

               console.log("相交面的索引："+intersects[0].faceIndex);

               console.log("组成相交面的顶点索引:" + intersects[0].indices);


               console.log("相交的对象:"+ intersects[0].object);



           }
                */
    }


    function animate(){

        requestAnimationFrame(animate);
        render();

    }

    function render(){

        TWEEN.update();
        controls.update();
        renderer.render(scene,camera);

    }


</script>

</body>
</html>
