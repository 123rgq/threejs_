<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>纹理投影测试</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
<script src="../../main/three.js"></script>
<script type="text/javascript" src="../../lib/js/controls/OrbitControls.js"></script>

<script type="x-shader/x-vertex" id="vertexshader">

        varying vec3 fragPosition;

        void main(void){

        mat4 mvp = projectionMatrix * modelViewMatrix ;

        fragPosition = position.xyz;

        gl_Position  = mvp * vec4(position,1.0);

        }

</script>

<script type="x-shader/x-fragment" id="fragmentshader">

        varying vec3 fragPosition;
        uniform mat4 modelMatrix;

        uniform mat4 projectorViewMatrix1;
        uniform mat4 projectorViewMatrix2;
        uniform mat4 projectorViewMatrix3;
        uniform mat4 projectorViewMatrix4;
        uniform mat4 projectorViewMatrix5;
        uniform mat4 projectorViewMatrix6;


        uniform mat4 projectorMatrix1;                                                                                   //
        uniform mat4 projectorMatrix2;                                                                                   //
        uniform mat4 projectorMatrix3;                                                                                   //
        uniform mat4 projectorMatrix4;                                                                                   //
        uniform mat4 projectorMatrix5;                                                                                   //
        uniform mat4 projectorMatrix6;                                                                                   //


        uniform sampler2D projectorMap1;
        uniform sampler2D projectorMap2;
        uniform sampler2D projectorMap3;
        uniform sampler2D projectorMap4;
        uniform sampler2D projectorMap5;
        uniform sampler2D projectorMap6;


        void main(void){

        vec4 projectorColor = vec4(0.0);

        vec4 positionInProjectorSpace =  projectorMatrix1 * projectorViewMatrix1 * modelMatrix * vec4(fragPosition,1.0);
        float z = positionInProjectorSpace.z;
        positionInProjectorSpace /= positionInProjectorSpace.w;
        vec2 projectorUV = (positionInProjectorSpace.xy+1.0) * 0.5  ;

       if(projectorUV.x >= 0.0 &&projectorUV.x <= 1.0 &&projectorUV.y>=0.0 && projectorUV.y <= 1.0 &&z>0.0)             // 投影空间的z值大于0 表示 投影在投影机的前面
       {
               projectorColor = texture2D(projectorMap1,projectorUV);
               gl_FragColor = vec4(projectorColor.rgb ,1.0);

       }

        vec4 positionInProjectorSpace2 =  projectorMatrix2 * projectorViewMatrix2 * modelMatrix * vec4(fragPosition,1.0);
         z = positionInProjectorSpace2.z;
        positionInProjectorSpace2 /= positionInProjectorSpace2.w;
        vec2 projectorUV2 = (positionInProjectorSpace2.xy+1.0) * 0.5;

       if(projectorUV2.x >= 0.0 &&projectorUV2.x <= 1.0 &&projectorUV2.y>=0.0 && projectorUV2.y <= 1.0 &&z>0.0)         // 投影空间的z值大于0 表示 投影在投影机的前面
       {
               projectorColor = texture2D(projectorMap2,projectorUV2);

               gl_FragColor = vec4(projectorColor.rgb ,1.0);

       }

        vec4 positionInProjectorSpace3 =  projectorMatrix3 * projectorViewMatrix3 * modelMatrix * vec4(fragPosition,1.0);
         z = positionInProjectorSpace3.z;
        positionInProjectorSpace3 /= positionInProjectorSpace3.w;
        vec2 projectorUV3 = (positionInProjectorSpace3.xy+1.0) * 0.5;

       if(projectorUV3.x >= 0.0 &&projectorUV3.x <= 1.0 &&projectorUV3.y>=0.0 && projectorUV3.y <= 1.0 &&z>0.0)         // 投影空间的z值大于0 表示 投影在投影机的前面
       {
               projectorColor = texture2D(projectorMap3,projectorUV3);

               gl_FragColor = vec4(projectorColor.rgb ,1.0);

       }

        vec4 positionInProjectorSpace4 =  projectorMatrix4 * projectorViewMatrix4 * modelMatrix * vec4(fragPosition,1.0);
        z = positionInProjectorSpace4.z;
        positionInProjectorSpace4 /= positionInProjectorSpace4.w;
        vec2 projectorUV4 = (positionInProjectorSpace4.xy+1.0) * 0.5;

       if(projectorUV4.x >= 0.0 &&projectorUV4.x <= 1.0 &&projectorUV4.y>=0.0 && projectorUV4.y <= 1.0 &&z>0.0)         // 投影空间的z值大于0 表示 投影在投影机的前面
       {
               projectorColor = texture2D(projectorMap4,projectorUV4);

               gl_FragColor = vec4(projectorColor.rgb ,1.0);

       }

        vec4 positionInProjectorSpace5 =  projectorMatrix5 * projectorViewMatrix5 * modelMatrix * vec4(fragPosition,1.0);
        z = positionInProjectorSpace5.z;
        positionInProjectorSpace5 /= positionInProjectorSpace5.w;
        vec2 projectorUV5 = (positionInProjectorSpace5.xy+1.0) * 0.5;

       if(projectorUV5.x >= 0.0 &&projectorUV5.x <= 1.0 &&projectorUV5.y>=0.0 && projectorUV5.y <= 1.0 &&z>0.0)         // 投影空间的z值大于0 表示 投影在投影机的前面
       {
               projectorColor = texture2D(projectorMap5,projectorUV5);

               gl_FragColor = vec4(projectorColor.rgb ,1.0);

       }
         vec4 positionInProjectorSpace6 =  projectorMatrix6 * projectorViewMatrix6 * modelMatrix * vec4(fragPosition,1.0);
         z = positionInProjectorSpace6.z;
         positionInProjectorSpace6 /= positionInProjectorSpace6.w;
         vec2 projectorUV6 = (positionInProjectorSpace6.xy+1.0) * 0.5;

       if(projectorUV6.x >= 0.0 &&projectorUV6.x <= 1.0 &&projectorUV6.y>=0.0 && projectorUV6.y <= 1.0 &&z>0.0)         // 投影空间的z值大于0 表示 投影在投影机的前面
       {
               projectorColor = texture2D(projectorMap6,projectorUV6);

               gl_FragColor = vec4(projectorColor.rgb ,1.0);

       }

      }

</script>


<div id="WebGL-output"></div>

<script>

    var camera, scene, renderer, control,cameraMap1,cameraMap2,cameraMap3,cameraMap4,cameraMap5,cameraMap6;

    function init() {

        var uniforms;

        scene = new THREE.Scene();

        renderer = new THREE.WebGLRenderer();

        renderer.setSize(window.innerWidth, window.innerHeight);

        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 40;
        camera.position.y = 10;
     //   console.log(camera.matrixWorld);

        control = new THREE.OrbitControls(camera);

        cameraMap1 = new THREE.PerspectiveCamera(90, 1, 0.1, 1000);
        cameraMap2 = new THREE.PerspectiveCamera(90, 1, 0.1, 1000);
        cameraMap3 = new THREE.PerspectiveCamera(90, 1, 0.1, 1000);
        cameraMap4 = new THREE.PerspectiveCamera(90, 1, 0.1, 1000);
        cameraMap5 = new THREE.PerspectiveCamera(90, 1, 0.1, 1000);
        cameraMap6 = new THREE.PerspectiveCamera(90, 1, 0.1, 1000);

        cameraMap1.rotation.x = Math.PI/2;                                                                              // top        -- 1
        cameraMap1.rotation.z = -Math.PI/2;                                                                             //  绕x旋转后       x --- x,  y --- z, z ---  -y;
        cameraMap1.updateMatrixWorld();

       // console.log(cameraMap1.matrixWorldInverse);

        console.log(cameraMap1.projectionMatrix);

        cameraMap2.rotation.y = Math.PI;                                                                                //front       -- 2
        cameraMap2.updateMatrixWorld();

        console.log(cameraMap2.projectionMatrix);

        cameraMap6.rotation.x = -Math.PI/2;                                                                             // bottom     -- 6
        cameraMap6.rotation.z = Math.PI;
        cameraMap6.updateMatrixWorld();

        cameraMap3.rotation.y = Math.PI/2;                                                                              // left       ---3
        cameraMap3.updateMatrixWorld();

        cameraMap5.rotation.y = -Math.PI/2;                                                                             // right      ---5
        cameraMap5.updateMatrixWorld();

        var cameraHelper = new THREE.CameraHelper(cameraMap4);

        scene.add(cameraHelper);

        var cubeGeo = new THREE.CubeGeometry(10, 10, 10);

      //  console.log(cameraMap4.matrixWorldInverse);

        uniforms = {
            projectorMap1: {value: (new THREE.TextureLoader()).load("./Pannorama_001_1_low.jpg")},                       //投影第1张图;
            projectorMap2: {value: (new THREE.TextureLoader()).load("./Pannorama_001_2_low.jpg")},                       //投影第2张图;
            projectorMap3: {value: (new THREE.TextureLoader()).load("./Pannorama_001_3_low.jpg")},                       //投影第3张图;
            projectorMap4: {value: (new THREE.TextureLoader()).load("./Pannorama_001_4_low.jpg")},                       //投影第4张图;
            projectorMap5: {value: (new THREE.TextureLoader()).load("./Pannorama_001_5_low.jpg")},                       //投影第5张图;
            projectorMap6: {value: (new THREE.TextureLoader()).load("./Pannorama_001_6_low.jpg")},                       //投影第6张图;

        /*  projectorMatrix1: {value: [1.000000000000000, 0, 0, 0, 0, 1.000000000000000, 0, 0, 0, 0, -1.000, -1, 0, 0, 0, 0]},
            projectorMatrix2: {value: [1.000000000000000, 0, 0, 0, 0, 1.000000000000000, 0, 0, 0, 0, -1.000, -1, 0, 0, 0, 0]},
            projectorMatrix3: {value: [1.000000000000000, 0, 0, 0, 0, 1.000000000000000, 0, 0, 0, 0, -1.000, -1, 0, 0, 0, 0]},
            projectorMatrix4: {value: [1.000000000000000, 0, 0, 0, 0, 1.000000000000000, 0, 0, 0, 0, -1.000, -1, 0, 0, 0, 0]},
            projectorMatrix5: {value: [1.000000000000000, 0, 0, 0, 0, 1.000000000000000, 0, 0, 0, 0, -1.000, -1, 0, 0, 0, 0]},
            projectorMatrix6: {value: [1.000000000000000, 0, 0, 0, 0, 1.000000000000000, 0, 0, 0, 0, -1.000, -1, 0, 0, 0, 0]}, */

            projectorMatrix1: {value: cameraMap1.projectionMatrix},
            projectorMatrix2: {value: cameraMap2.projectionMatrix},
            projectorMatrix3: {value: cameraMap3.projectionMatrix},
            projectorMatrix4: {value: cameraMap4.projectionMatrix},
            projectorMatrix5: {value: cameraMap5.projectionMatrix},
            projectorMatrix6: {value: cameraMap6.projectionMatrix},

            projectorViewMatrix1: {value: cameraMap1.matrixWorldInverse},
            projectorViewMatrix2: {value: cameraMap2.matrixWorldInverse},
            projectorViewMatrix3: {value: cameraMap3.matrixWorldInverse},
            projectorViewMatrix4: {value: cameraMap4.matrixWorldInverse},
            projectorViewMatrix5: {value: cameraMap5.matrixWorldInverse},
            projectorViewMatrix6: {value: cameraMap6.matrixWorldInverse}


        };
        var shaderMaterial = new THREE.ShaderMaterial(
            {
                side: THREE.BackSide,
              //  side:THREE.DoubleSide,
                uniforms: uniforms,
                vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById(('fragmentshader')).textContent,
                depthTest: false
                //transparent: true

            });
        var cube = new THREE.Mesh(cubeGeo, shaderMaterial);

        document.onmousedown = function () {

          //  cameraMap4.position.z=10.11;
            cameraMap4.updateMatrixWorld ();

          //  console.log("123");

        }
        var planeGeo = new THREE.PlaneGeometry(40,40,1,1);

        var planMaterial = new THREE.MeshBasicMaterial({color:0xff0000}); // 平板颜色

        var plane = new THREE.Mesh(planeGeo , planMaterial); // 场景中添加平板


      //  scene.add(plane);


        scene.add(cube);
        document.getElementById('WebGL-output').appendChild(renderer.domElement);
        animate();

    }

    function rend() {
        control.update();
        renderer.render(scene, camera);
    }

    function animate() {
        rend();
        requestAnimationFrame(animate);
    }

    init();

</script>

</body>
</html>